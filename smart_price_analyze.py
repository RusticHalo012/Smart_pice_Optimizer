# -*- coding: utf-8 -*-
"""Smart_Price_Analyze.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lgX3Si2VSEnGXc3pdSd9qTr0f86ECL6F
"""

import streamlit as st
import pandas as pd
import altair as alt
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import OrdinalEncoder
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer

# --- Page Configuration ---
st.set_page_config(
    page_title="Smart Price Analyzer",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- Data Loading ---
@st.cache_data
def load_data(filepath="data.csv"):
    """
    Loads and preprocesses the retail data.
    """
    try:
        df = pd.read_csv(filepath, encoding="latin1")
    except FileNotFoundError:
        st.error(f"Error: {filepath} not found. Make sure it's in the same directory.")
        return None, None

    # 1. Filter out returns and invalid entries
    df_clean = df[(df['Quantity'] > 0) & (df['UnitPrice'] > 0)].copy()

    # 2. Drop columns we don't need for the model, but keep CustomerID for analysis
    df_analysis = df_clean.copy() # Keep a copy for analysis
    df_clean = df_clean.drop(columns=['InvoiceNo'])

    # 3. Handle missing descriptions
    df_clean = df_clean.dropna(subset=['Description'])
    df_analysis = df_analysis.dropna(subset=['Description', 'CustomerID']) # Also drop NaNs for customer analysis

    # 4. Feature Engineering
    df_clean['InvoiceDate'] = pd.to_datetime(df_clean['InvoiceDate'])
    df_clean['Month'] = df_clean['InvoiceDate'].dt.month
    df_clean['DayOfWeek'] = df_clean['InvoiceDate'].dt.dayofweek
    df_clean['TotalPrice'] = df_clean['Quantity'] * df_clean['UnitPrice']

    # Do the same for the analysis dataframe
    df_analysis['InvoiceDate'] = pd.to_datetime(df_analysis['InvoiceDate'])
    df_analysis['YearMonth'] = df_analysis['InvoiceDate'].dt.to_period('M').astype(str)
    df_analysis['TotalPrice'] = df_analysis['Quantity'] * df_analysis['UnitPrice']


    # 5. Define features (X) and target (y)
    features = ['StockCode', 'Country', 'Quantity', 'Month', 'DayOfWeek']
    target = 'UnitPrice'

    # Drop NaNs in our specific columns for the model
    df_model = df_clean[features + [target]].dropna()

    X = df_model[features]
    y = df_model[target]

    return df_analysis, X, y

# --- Model Training ---
@st.cache_resource
def train_model(X, y):
    """
    Defines a preprocessing pipeline and trains a Random Forest Regressor.
    """
    # Define categorical features for encoding
    categorical_features = ['StockCode', 'Country']

    # Create a column transformer
    preprocessor = ColumnTransformer(
        transformers=[
            ('cat', OrdinalEncoder(handle_unknown='use_encoded_value', unknown_value=-1), categorical_features)
        ],
        remainder='passthrough'
    )

    # Create the full pipeline
    model_pipeline = Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('regressor', RandomForestRegressor(n_estimators=100, random_state=42, n_jobs=-1))
    ])

    # Train the model
    model_pipeline.fit(X, y)

    return model_pipeline

# --- Load Data and Train Model ---
# df_clean is now named df_analysis for clarity
df_analysis, X, y = load_data()

if df_analysis is not None:
    model_pipeline = train_model(X, y)

    # --- Sidebar Navigation ---
    st.sidebar.title("Navigation")
    page = st.sidebar.radio("Choose a page:", ["Price Prediction", "Data Analysis"])
    st.sidebar.info("This app predicts the **Unit Price** of an item based on its characteristics.")

    # ==============================================================================
    # --- Price Prediction Page ---
    # ==============================================================================
    if page == "Price Prediction":
        st.title("üõçÔ∏è Smart Price Predictor")
        st.write("Select the features of an item to predict its `UnitPrice`.")

        col1, col2 = st.columns(2)

        with col1:
            # Get unique values for dropdowns
            unique_stock_codes = sorted(X['StockCode'].unique())
            unique_countries = sorted(X['Country'].unique())

            # --- User Inputs ---
            stock_code = st.selectbox("Stock Code:", options=unique_stock_codes)
            country = st.selectbox("Country:", options=unique_countries)

        with col2:
            quantity = st.number_input("Quantity:", min_value=1, max_value=1000, value=1)
            month = st.select_slider("Month:", options=list(range(1, 13)), value=12)
            day_of_week = st.select_slider("Day of Week:", options=list(range(7)),
                                           format_func=lambda x: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'][x])

        # --- Prediction ---
        if st.button("üöÄ Predict Price"):
            # Create a DataFrame from inputs
            input_data = pd.DataFrame({
                'StockCode': [stock_code],
                'Country': [country],
                'Quantity': [quantity],
                'Month': [month],
                'DayOfWeek': [day_of_week]
            })

            # Make prediction
            try:
                prediction = model_pipeline.predict(input_data)
                st.success(f"**Predicted Unit Price:** `${prediction[0]:.2f}`")
            except Exception as e:
                st.error(f"An error occurred during prediction: {e}")

    # ==============================================================================
    # --- Data Analysis Page ---
    # ==============================================================================
    elif page == "Data Analysis":
        st.title("üìä Data Analysis Dashboard")

        # --- Key Metrics ---
        st.subheader("High-Level Metrics")
        total_revenue = df_analysis['TotalPrice'].sum()
        total_orders = df_analysis['TotalPrice'].count()
        avg_price = df_analysis['UnitPrice'].mean()

        kpi1, kpi2, kpi3 = st.columns(3)
        kpi1.metric("Total Revenue", f"${total_revenue:,.2f}")
        kpi2.metric("Total Items Sold", f"{total_orders:,}")
        kpi3.metric("Average Unit Price", f"${avg_price:.2f}")

        st.markdown("---")

        # --- NEW: Sales Over Time ---
        st.subheader("Monthly Sales Revenue")
        monthly_sales = df_analysis.groupby('YearMonth')['TotalPrice'].sum().reset_index()

        chart_monthly_sales = alt.Chart(monthly_sales).mark_line(point=True).encode(
            x=alt.X('YearMonth', title='Month'),
            y=alt.Y('TotalPrice', title='Total Revenue'),
            tooltip=['YearMonth', 'TotalPrice']
        ).interactive()
        st.altair_chart(chart_monthly_sales, use_container_width=True)

        st.markdown("---")

        # --- Top 10 Charts ---
        col1, col2 = st.columns(2)

        with col1:
            st.subheader("Top 10 Countries by Revenue")
            country_revenue = df_analysis.groupby('Country')['TotalPrice'].sum().reset_index()
            country_revenue = country_revenue.sort_values(by='TotalPrice', ascending=False).head(10)

            chart_country = alt.Chart(country_revenue).mark_bar().encode(
                x=alt.X('TotalPrice', title='Total Revenue'),
                y=alt.Y('Country', sort='-x', title='Country'),
                tooltip=['Country', 'TotalPrice']
            ).interactive()
            st.altair_chart(chart_country, use_container_width=True)

        with col2:
            st.subheader("Top 10 Products by Revenue")
            product_revenue = df_analysis.groupby('Description')['TotalPrice'].sum().reset_index()
            product_revenue = product_revenue.sort_values(by='TotalPrice', ascending=False).head(10)

            chart_product = alt.Chart(product_revenue).mark_bar().encode(
                x=alt.X('TotalPrice', title='Total Revenue'),
                y=alt.Y('Description', sort='-x', title='Product Description'),
                tooltip=['Description', 'TotalPrice']
            ).interactive()
            st.altair_chart(chart_product, use_container_width=True)

        st.markdown("---")

        # --- NEW: Top Customers ---
        st.subheader("Top 10 Customers by Revenue")
        # Ensure CustomerID is treated as a string/object for correct grouping
        df_analysis['CustomerID'] = df_analysis['CustomerID'].astype(int).astype(str)
        customer_revenue = df_analysis.groupby('CustomerID')['TotalPrice'].sum().reset_index()
        customer_revenue = customer_revenue.sort_values(by='TotalPrice', ascending=False).head(10)

        chart_customer = alt.Chart(customer_revenue).mark_bar().encode(
            x=alt.X('TotalPrice', title='Total Revenue'),
            y=alt.Y('CustomerID', sort='-x', title='Customer ID'),
            tooltip=['CustomerID', 'TotalPrice']
        ).interactive()
        st.altair_chart(chart_customer, use_container_width=True)

        st.markdown("---")

        # --- Price and Quantity Distributions ---
        col3, col4 = st.columns(2)

        with col3:
            st.subheader("Unit Price Distribution")
            # Filter for better visualization (e.g., items < $20)
            df_price_dist = df_analysis[df_analysis['UnitPrice'] < 20]

            chart_price = alt.Chart(df_price_dist).mark_bar().encode(
                x=alt.X('UnitPrice', bin=alt.Bin(maxbins=100), title='Unit Price'),
                y=alt.Y('count()', title='Frequency'),
                tooltip=[alt.Tooltip('UnitPrice', bin=True), 'count()']
            ).interactive()
            st.altair_chart(chart_price, use_container_width=True)

        with col4:
            # --- NEW: Quantity vs UnitPrice Scatter Plot ---
            st.subheader("Quantity vs. Unit Price")
            # Sample for performance if needed, and filter outliers
            df_scatter = df_analysis[
                (df_analysis['Quantity'] < 200) & (df_analysis['UnitPrice'] < 100)
            ].sample(n=2000, replace=True, random_state=1) # Sample 2000 points

            chart_scatter = alt.Chart(df_scatter).mark_circle(opacity=0.5).encode(
                x=alt.X('Quantity'),
                y=alt.Y('UnitPrice'),
                tooltip=['Quantity', 'UnitPrice', 'Description']
            ).interactive()
            st.altair_chart(chart_scatter, use_container_width=True)

else:
    st.error("Data could not be loaded. Please check the file path and try again.")